<!DOCTYPE html>
<html lang="pl">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>🌟 Lux AI Assistant - Session Context</title>
    <style>
        .session-sidebar {
            position: fixed;
            right: 0;
            top: 0;
            width: 300px;
            height: 100vh;
            background: #f8f9fa;
            border-left: 1px solid #e9ecef;
            padding: 20px;
            overflow-y: auto;
            z-index: 1000;
        }

        .context-info, .project-tags, .recent-activity {
            margin-bottom: 20px;
            padding: 15px;
            background: white;
            border-radius: 8px;
            box-shadow: 0 2px 4px rgba(0,0,0,0.1);
        }

        .tag {
            display: inline-block;
            padding: 4px 8px;
            background: #007bff;
            color: white;
            border-radius: 4px;
            margin: 2px;
            font-size: 12px;
        }

        .tag-luxunda { background: #28a745; }
        .tag-deployment { background: #ffc107; }
        .tag-database { background: #17a2b8; }

        .action-notification {
            position: fixed;
            top: 20px;
            right: 320px;
            background: #28a745;
            color: white;
            padding: 10px 15px;
            border-radius: 4px;
            z-index: 1001;
            animation: slideIn 0.3s ease-out;
        }

        @keyframes slideIn {
            from { transform: translateX(100%); }
            to { transform: translateX(0); }
        }

        .main-content {
            margin-right: 320px; /* Make space for sidebar */
        }

        #thinking-indicator {
            display: none;
            padding: 10px;
            background: #fff3cd;
            border: 1px solid #ffeaa7;
            border-radius: 4px;
            margin: 10px 0;
            font-style: italic;
        }
    </style>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            height: 100vh;
            overflow: hidden;
            color: white;
        }

        .lux-container {
            display: flex;
            height: 100vh;
            background: rgba(255, 255, 255, 0.1);
            backdrop-filter: blur(10px);
        }

        .sidebar {
            width: 300px;
            background: rgba(0, 0, 0, 0.2);
            backdrop-filter: blur(20px);
            border-right: 1px solid rgba(255, 255, 255, 0.1);
            padding: 20px;
            color: white;
            display: flex;
            flex-direction: column;
        }

        .main-chat {
            flex: 1;
            display: flex;
            flex-direction: column;
            position: relative;
        }

        .chat-header {
            background: rgba(255, 255, 255, 0.1);
            backdrop-filter: blur(10px);
            padding: 20px;
            border-bottom: 1px solid rgba(255, 255, 255, 0.1);
            color: white;
            text-align: center;
        }

        .chat-messages {
            flex: 1;
            overflow-y: auto;
            padding: 20px;
            display: flex;
            flex-direction: column;
            gap: 15px;
        }

        .message {
            max-width: 80%;
            padding: 15px 20px;
            border-radius: 20px;
            backdrop-filter: blur(10px);
            animation: fadeInUp 0.3s ease;
        }

        .message.user {
            align-self: flex-end;
            background: rgba(255, 255, 255, 0.2);
            color: white;
            border: 1px solid rgba(255, 255, 255, 0.3);
        }

        .message.lux {
            align-self: flex-start;
            background: rgba(0, 0, 0, 0.3);
            color: white;
            border: 1px solid rgba(255, 255, 255, 0.1);
        }

        .message.system {
            align-self: center;
            background: rgba(255, 215, 0, 0.2);
            color: #ffd700;
            border: 1px solid rgba(255, 215, 0, 0.3);
            text-align: center;
        }

        .thinking {
            align-self: flex-start;
            background: rgba(0, 0, 0, 0.3);
            color: #aaa;
            border: 1px solid rgba(255, 255, 255, 0.1);
            animation: pulse 1.5s infinite;
        }

        .chat-input-container {
            padding: 20px;
            background: rgba(0, 0, 0, 0.2);
            backdrop-filter: blur(10px);
            border-top: 1px solid rgba(255, 255, 255, 0.1);
        }

        .chat-input {
            width: 100%;
            padding: 15px 20px;
            border: none;
            border-radius: 25px;
            background: rgba(255, 255, 255, 0.1);
            backdrop-filter: blur(10px);
            color: white;
            font-size: 16px;
            outline: none;
            border: 1px solid rgba(255, 255, 255, 0.2);
        }

        .chat-input::placeholder {
            color: rgba(255, 255, 255, 0.6);
        }

        .chat-input:focus {
            border-color: rgba(255, 255, 255, 0.5);
            box-shadow: 0 0 20px rgba(255, 255, 255, 0.1);
        }

        .tools-list {
            margin-top: 20px;
            flex-grow: 1; /* Allow tools list to take available space */
        }

        .tool-item {
            background: rgba(255, 255, 255, 0.1);
            border-radius: 10px;
            padding: 10px;
            margin-bottom: 10px;
            border: 1px solid rgba(255, 255, 255, 0.1);
            transition: all 0.3s ease;
        }

        .tool-item:hover {
            background: rgba(255, 255, 255, 0.2);
            transform: translateY(-2px);
        }

        @keyframes fadeInUp {
            from {
                opacity: 0;
                transform: translateY(20px);
            }
            to {
                opacity: 1;
                transform: translateY(0);
            }
        }

        @keyframes pulse {
            0%, 100% { opacity: 1; }
            50% { opacity: 0.5; }
        }

        .logo {
            font-size: 24px;
            font-weight: bold;
            margin-bottom: 20px;
            text-align: center;
            background: linear-gradient(45deg, #ffd700, #ffffff);
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
        }

        .status {
            background: rgba(0, 255, 0, 0.2);
            border: 1px solid rgba(0, 255, 0, 0.3);
            border-radius: 10px;
            padding: 10px;
            text-align: center;
            margin-bottom: 20px;
            color: #00ff00;
        }

        /* Access Control Styles */
        .access-btn {
            background: linear-gradient(45deg, #ff6b35, #f7931e);
            color: white;
            border: none;
            padding: 8px 16px;
            border-radius: 6px;
            cursor: pointer;
            margin-left: 10px;
        }

        .access-summary {
            background: rgba(255, 255, 255, 0.05);
            border: 1px solid #333;
            border-radius: 8px;
            padding: 15px;
            margin-bottom: 20px;
        }

        .summary-stats {
            display: flex;
            gap: 20px;
            margin-bottom: 15px;
        }

        .stat {
            display: flex;
            flex-direction: column;
            align-items: center;
            padding: 10px;
            background: rgba(0, 255, 136, 0.1);
            border-radius: 6px;
        }

        .stat .label {
            font-size: 0.9em;
            color: #ccc;
        }

        .stat .value {
            font-size: 1.5em;
            font-weight: bold;
            color: #00ff88;
        }

        .zones-breakdown {
            display: grid;
            gap: 10px;
        }

        .zone-summary {
            padding: 10px;
            border-radius: 6px;
            border: 1px solid #333;
        }

        .zone-summary.accessible {
            background: rgba(0, 255, 136, 0.1);
            border-color: #00ff88;
        }

        .zone-summary.denied {
            background: rgba(255, 68, 68, 0.1);
            border-color: #ff4444;
        }

        .zone-header {
            font-weight: bold;
            font-size: 1.1em;
            margin-bottom: 5px;
        }

        .zone-details {
            font-size: 0.9em;
            color: #ccc;
        }

        .zone-stats {
            margin-top: 5px;
            font-size: 0.8em;
            color: #999;
        }

        .zones-section {
            margin-bottom: 20px;
        }

        .zone-card {
            background: rgba(255, 255, 255, 0.05);
            border: 1px solid #333;
            border-radius: 8px;
            padding: 15px;
            margin-bottom: 10px;
        }

        .zone-card.public {
            border-left: 4px solid #00ff88;
        }

        .zone-card.authenticated {
            border-left: 4px solid #ffa500;
        }

        .zone-card.sensitive {
            border-left: 4px solid #ff4444;
        }

        .zone-title {
            display: flex;
            justify-content: space-between;
            align-items: center;
            font-weight: bold;
            margin-bottom: 8px;
        }

        .zone-btn {
            background: #333;
            color: white;
            border: 1px solid #555;
            padding: 4px 8px;
            border-radius: 4px;
            cursor: pointer;
            font-size: 0.8em;
        }

        .zone-btn:hover {
            background: #555;
        }

        .zone-description {
            color: #ccc;
            margin-bottom: 8px;
            font-size: 0.9em;
        }

        .create-secured-being {
            background: rgba(255, 255, 255, 0.05);
            border: 1px solid #333;
            border-radius: 8px;
            padding: 15px;
        }

        .create-secured-being form {
            display: grid;
            gap: 10px;
        }

        .create-secured-being input,
        .create-secured-being select,
        .create-secured-being textarea {
            padding: 8px;
            background: #1a1a1a;
            border: 1px solid #333;
            border-radius: 4px;
            color: white;
        }

        .create-secured-being button {
            background: linear-gradient(45deg, #ff6b35, #f7931e);
            color: white;
            border: none;
            padding: 10px;
            border-radius: 6px;
            cursor: pointer;
            font-weight: bold;
        }

        .back-btn {
            background: #333;
            color: white;
            border: 1px solid #555;
            padding: 8px 12px;
            border-radius: 4px;
            cursor: pointer;
            margin-bottom: 10px;
        }

        .panel {
            padding: 20px;
        }

    </style>
    <script src="/static/session-context.js"></script>
</head>
<body>
    <div class="lux-container" id="mainInterface">
        <!-- Sidebar -->
        <div class="sidebar">
            <div class="logo">🌟 Lux AI</div>
            <div class="status" id="connectionStatus">
                Łączenie...
            </div>

            <h3>Dostępne narzędzia:</h3>
            <div class="tools-list" id="toolsList">
                <div class="tool-item">Ładowanie...</div>
            </div>
        </div>

        <!-- Main Chat Area -->
        <div class="main-chat">
            <div class="chat-header">
                <h1>🌟 Lux AI Assistant</h1>
                <p>Twój inteligentny asystent do zarządzania bytami i narzędziami</p>
            </div>

            <div class="chat-messages" id="chatMessages">
                <!-- Messages will appear here -->
            </div>

            <div class="chat-input-container">
                <input
                    type="text"
                    id="messageInput"
                    class="chat-input"
                    placeholder="Porozmawiaj z Lux... (np. 'Potrzebuję zapisać notatkę z dnia' lub 'Zbuduj mi kalkulator')"
                    maxlength="500"
                >
            </div>
        </div>
    </div>

    <!-- Access Control Panel -->
    <div id="accessControlPanel" class="panel" style="display: none;">
        <h3>🛡️ Access Control & Security Zones</h3>

        <div class="access-summary" id="accessSummary">
            <h4>Your Access Summary</h4>
            <div id="accessSummaryContent">Loading...</div>
        </div>

        <div class="zones-section">
            <h4>Security Zones</h4>
            <div id="zonesContent">Loading zones...</div>
        </div>

        <div class="create-secured-being">
            <h4>Create Secured Being</h4>
            <form id="securedBeingForm">
                <input type="text" id="soulAlias" placeholder="Soul Alias" required>
                <input type="text" id="beingAlias" placeholder="Being Alias (optional)">
                <select id="accessLevel">
                    <option value="public">Public (everyone)</option>
                    <option value="authenticated" selected>Authenticated (logged users)</option>
                    <option value="sensitive">Sensitive (special permissions)</option>
                </select>
                <input type="number" id="ttlHours" placeholder="TTL Hours (optional)">
                <textarea id="beingData" placeholder="Being Data (JSON)">{"name": "My Secured Being"}</textarea>
                <button type="submit">🔐 Create Secured Being</button>
            </form>
        </div>
    </div>

    <script>
        // Mock functions and variables that were previously global or implied
        let ws;
        let isConnected = false;
        let heartbeatInterval;
        let lastHeartbeat = Date.now();
        let reconnectAttempts = 0;

        function generateFingerprint() {
            // A simple example, ideally more robust
            return `fp_${Date.now()}_${Math.random().toString(36).substring(2, 15)}`;
        }

        // User identification
        const userFingerprint = generateFingerprint();

        function showStatus(message, type) {
            const statusDiv = document.getElementById('connectionStatus');
            if (statusDiv) {
                statusDiv.textContent = message;
                statusDiv.className = 'status'; // Reset classes
                if (type === 'success') {
                    statusDiv.classList.add('status-success'); // Add specific success class if needed
                    statusDiv.style.background = 'rgba(0, 255, 0, 0.2)';
                    statusDiv.style.borderColor = 'rgba(0, 255, 0, 0.3)';
                    statusDiv.style.color = '#00ff00';
                } else if (type === 'error') {
                    statusDiv.classList.add('status-error'); // Add specific error class
                    statusDiv.style.background = 'rgba(255, 0, 0, 0.2)';
                    statusDiv.style.borderColor = 'rgba(255, 0, 0, 0.3)';
                    statusDiv.style.color = '#ff0000';
                } else {
                     statusDiv.style.background = 'rgba(0, 255, 0, 0.2)'; // Default to green if type is not specified or unknown
                    statusDiv.style.borderColor = 'rgba(0, 255, 0, 0.3)';
                    statusDiv.style.color = '#00ff00';
                }
            }
        }

        function sendMessage(type, messageContent) {
            // This function is used internally by the WebSocket logic
            // If it's meant for the user interface, it should be called through LuxInterface
            if (ws && ws.readyState === WebSocket.OPEN) {
                const messageToSend = {
                    type: type,
                    payload: messageContent,
                    timestamp: new Date().toISOString(),
                    sender_fingerprint: userFingerprint
                };
                ws.send(JSON.stringify(messageToSend));
            } else {
                console.warn("WebSocket is not open. Message not sent:", messageContent);
            }
        }


        // WebSocket connection with improved stability and responsiveness
        function connectWebSocket() {
            try {
                const protocol = window.location.protocol === 'https:' ? 'wss:' : 'ws:';
                const wsUrl = `${protocol}//${window.location.host}/ws`;

                ws = new WebSocket(wsUrl);

                // Set timeout for connection
                const connectionTimeout = setTimeout(() => {
                    if (ws.readyState === WebSocket.CONNECTING) {
                        ws.close();
                        console.log('⏱️ WebSocket connection timeout');
                        setTimeout(connectWebSocket, 2000);
                    }
                }, 10000);

                ws.onopen = function(event) {
                    clearTimeout(connectionTimeout);
                    console.log('🌟 Connected to Lux!');
                    isConnected = true;
                    showStatus('Connected to LuxOS', 'success');

                    // Send initial connection message with user info
                    const userInfo = {
                        type: 'connection',
                        fingerprint: userFingerprint,
                        timestamp: new Date().toISOString(),
                        client_info: {
                            user_agent: navigator.userAgent,
                            screen: `${screen.width}x${screen.height}`,
                            timezone: Intl.DateTimeFormat().resolvedOptions().timeZone
                        }
                    };

                    if (ws.readyState === WebSocket.OPEN) {
                        ws.send(JSON.stringify(userInfo));
                    }

                    // Setup heartbeat to keep connection alive
                    startHeartbeat();
                };

                ws.onmessage = function(event) {
                    try {
                        const data = JSON.parse(event.data);

                        // Handle heartbeat response
                        if (data.type === 'pong') {
                            lastHeartbeat = Date.now();
                            return;
                        }

                        handleMessage(data);
                    } catch (e) {
                        console.error('Failed to parse message:', e);
                    }
                };

                ws.onclose = function(event) {
                    clearTimeout(connectionTimeout);
                    console.log('❌ Disconnected from Lux', event.code, event.reason);
                    isConnected = false;
                    showStatus('Disconnected from LuxOS', 'error');

                    // Stop heartbeat
                    stopHeartbeat();

                    // Attempt to reconnect with exponential backoff
                    const delay = Math.min(reconnectAttempts * 1000, 30000);
                    reconnectAttempts++;

                    setTimeout(() => {
                        if (!isConnected) {
                            connectWebSocket();
                        }
                    }, delay);
                };

                ws.onerror = function(error) {
                    console.error('WebSocket error:', error);
                    showStatus('Connection error - retrying...', 'error');
                };

            } catch (error) {
                console.error('Failed to initialize WebSocket:', error);
                setTimeout(connectWebSocket, 5000);
            }
        }

        // Heartbeat system to keep connection alive
        function startHeartbeat() {
            heartbeatInterval = setInterval(() => {
                if (ws && ws.readyState === WebSocket.OPEN) {
                    ws.send(JSON.stringify({type: 'ping', timestamp: Date.now()}));

                    // Check if we received a response recently
                    if (Date.now() - lastHeartbeat > 30000) {
                        console.log('💔 Heartbeat timeout - reconnecting');
                        ws.close();
                    }
                }
            }, 10000); // Send ping every 10 seconds
        }

        function stopHeartbeat() {
            if (heartbeatInterval) {
                clearInterval(heartbeatInterval);
                heartbeatInterval = null;
            }
        }

        class LuxInterface {
            constructor() {
                this.ws = null;
                this.reconnectAttempts = 0;
                this.maxReconnectAttempts = 10;
                this.reconnectDelay = 1000;
                this.isConnected = false;
                this.messageQueue = [];
                this.toolsRefreshTimeout = null;

                this.messageInput = document.getElementById('messageInput');
                this.chatMessages = document.getElementById('chatMessages');
                this.toolsList = document.getElementById('toolsList');
                this.connectionStatus = document.getElementById('connectionStatus');
                this.accessBtn = document.querySelector('.access-btn');
                this.backBtn = document.querySelector('.back-btn');

                this.setupEventListeners();
                this.connect();
                this.loadTools();
            }

            connect() {
                if (this.ws && this.ws.readyState === WebSocket.OPEN) {
                    return;
                }

                const wsUrl = `ws://${window.location.host}/ws`;
                console.log('🔌 Connecting to:', wsUrl);

                this.ws = new WebSocket(wsUrl);

                this.ws.onopen = (event) => {
                    console.log('🌟 Connected to Lux!');
                    this.isConnected = true;
                    this.reconnectAttempts = 0;
                    this.updateConnectionStatus('🟢 Połączono');

                    // Send queued messages
                    while (this.messageQueue.length > 0) {
                        const queuedMessage = this.messageQueue.shift();
                        this.ws.send(JSON.stringify(queuedMessage));
                    }

                    // Initialize session
                    this.sendMessage({
                        type: "init_session",
                        user_info: {
                            user_agent: navigator.userAgent,
                            screen_resolution: `${screen.width}x${screen.height}`,
                            timezone: Intl.DateTimeFormat().resolvedOptions().timeZone
                        }
                    });
                };

                this.ws.onmessage = (event) => {
                    try {
                        const data = JSON.parse(event.data);
                        this.handleMessage(data);
                    } catch (error) {
                        console.error('❌ Error parsing message:', error);
                    }
                };

                this.ws.onclose = (event) => {
                    this.isConnected = false;
                    console.log('❌ Disconnected from Lux');
                    this.updateConnectionStatus('🔴 Rozłączono');

                    if (this.reconnectAttempts < this.maxReconnectAttempts) {
                        const delay = Math.min(this.reconnectDelay * Math.pow(1.5, this.reconnectAttempts), 10000);
                        this.reconnectAttempts++;

                        setTimeout(() => {
                            console.log(`🔄 Reconnecting... (${this.reconnectAttempts}/${this.maxReconnectAttempts})`);
                            this.connect();
                        }, delay);
                    } else {
                        this.updateConnectionStatus('❌ Błąd połączenia');
                    }
                };

                this.ws.onerror = (error) => {
                    console.error('WebSocket error:', error);
                    this.isConnected = false;
                };
            }

            updateConnectionStatus(status) {
                if (this.connectionStatus) {
                    this.connectionStatus.textContent = status;
                    this.connectionStatus.className = this.isConnected ? 'status connected' : 'status disconnected';
                }
            }

            setupEventListeners() {
                this.messageInput.addEventListener('keypress', (e) => {
                    if (e.key === 'Enter' && !e.shiftKey) {
                        e.preventDefault();
                        this.sendMessage();
                    }
                });

                if (this.accessBtn) {
                    this.accessBtn.addEventListener('click', () => {
                        document.getElementById('mainInterface').style.display = 'none';
                        document.getElementById('accessControlPanel').style.display = 'block';
                        this.loadAccessData();
                    });
                }

                if (this.backBtn) {
                    this.backBtn.addEventListener('click', () => {
                        document.getElementById('accessControlPanel').style.display = 'none';
                        document.getElementById('mainInterface').style.display = 'block';
                    });
                }

                document.getElementById('securedBeingForm').addEventListener('submit', async (e) => {
                    e.preventDefault();

                    const token = localStorage.getItem('luxToken');
                    if (!token) {
                        alert('You must be logged in to create secured beings');
                        return;
                    }

                    const formData = {
                        soul_alias: document.getElementById('soulAlias').value,
                        alias: document.getElementById('beingAlias').value || null,
                        access_level: document.getElementById('accessLevel').value,
                        ttl_hours: document.getElementById('ttlHours').value ? parseInt(document.getElementById('ttlHours').value) : null,
                        data: JSON.parse(document.getElementById('beingData').value || '{}')
                    };

                    try {
                        const response = await fetch('/api/beings/create_secured', {
                            method: 'POST',
                            headers: {
                                'Content-Type': 'application/json',
                                'Authorization': `Bearer ${token}`
                            },
                            body: JSON.stringify(formData)
                        });

                        const result = await response.json();

                        if (result.success) {
                            alert(`✅ ${result.message}`);
                            document.getElementById('securedBeingForm').reset();
                            this.loadAccessData(); // Refresh access data
                        } else {
                            alert(`❌ Error: ${result.error}`);
                        }
                    } catch (error) {
                        console.error('Error creating secured being:', error);
                        alert('Error creating secured being');
                    }
                });
            }

            sendMessage(messageData = null) {
                let data;

                if (messageData) {
                    data = messageData;
                } else {
                    const message = this.messageInput.value.trim();
                    if (!message) return;

                    data = {
                        type: 'user_message',
                        message: message
                    };

                    // Add user message to UI immediately
                    this.addMessage(message, 'user');
                    this.messageInput.value = '';
                }

                // Send message or queue if not connected
                if (this.isConnected && this.ws.readyState === WebSocket.OPEN) {
                    this.ws.send(JSON.stringify(data));
                } else {
                    this.messageQueue.push(data);
                    if (!messageData) {
                        this.addMessage('📤 Wiadomość w kolejce...', 'system');
                    }
                }
            }

            handleMessage(data) {
                switch (data.type) {
                    case 'system':
                        this.addMessage(data.message, 'system');
                        break;
                    case 'thinking':
                        this.addThinkingMessage();
                        break;
                    case 'lux_response':
                        this.removeThinkingMessage();
                        this.addMessage(data.message, 'lux');
                        // Refresh tools after response (debounced)
                        clearTimeout(this.toolsRefreshTimeout);
                        this.toolsRefreshTimeout = setTimeout(() => this.loadTools(), 500);
                        break;
                    default:
                        console.log('📨 Unknown message type:', data.type, data);
                }
            }

            addMessage(content, type) {
                const messageDiv = document.createElement('div');
                messageDiv.className = `message ${type}`;
                messageDiv.textContent = content;

                this.chatMessages.appendChild(messageDiv);
                this.chatMessages.scrollTop = this.chatMessages.scrollHeight;
            }

            addThinkingMessage() {
                const thinkingDiv = document.createElement('div');
                thinkingDiv.className = 'message thinking';
                thinkingDiv.id = 'thinkingMessage';
                thinkingDiv.textContent = '🤔 Lux myśli...';

                this.chatMessages.appendChild(thinkingDiv);
                this.chatMessages.scrollTop = this.chatMessages.scrollHeight;
            }

            removeThinkingMessage() {
                const thinking = document.getElementById('thinkingMessage');
                if (thinking) {
                    thinking.remove();
                }
            }

            async loadTools() {
                try {
                    const response = await fetch('/api/tools');
                    const data = await response.json();

                    this.toolsList.innerHTML = '';

                    if (data.tools && data.tools.length > 0) {
                        data.tools.forEach(tool => {
                            const toolDiv = document.createElement('div');
                            toolDiv.className = 'tool-item';
                            toolDiv.innerHTML = `
                                <strong>${tool.alias || tool.ulid.substring(0, 8)}</strong><br>
                                <small>${tool.type} - ${tool.description}</small>
                            `;
                            this.toolsList.appendChild(toolDiv);
                        });
                    } else {
                        this.toolsList.innerHTML = '<div class="tool-item">Brak narzędzi</div>';
                    }

                } catch (error) {
                    console.error('Failed to load tools:', error);
                    this.toolsList.innerHTML = '<div class="tool-item">Błąd ładowania</div>';
                }
            }

            async loadAccessData() {
                const token = localStorage.getItem('luxToken');
                if (!token) return;

                try {
                    const summaryResponse = await fetch('/api/access/summary', {
                        headers: token ? { 'Authorization': `Bearer ${token}` } : {}
                    });
                    const summaryData = await summaryResponse.json();

                    if (summaryData.access_summary) {
                        this.displayAccessSummary(summaryData.access_summary);
                    }

                    const zonesResponse = await fetch('/api/access/zones');
                    const zonesData = await zonesResponse.json();

                    if (zonesData.zones) {
                        this.displayZones(zonesData.zones);
                    }

                } catch (error) {
                    console.error('Error loading access data:', error);
                }
            }

            displayAccessSummary(summary) {
                const content = document.getElementById('accessSummaryContent');
                let html = `
                    <div class="summary-stats">
                        <div class="stat">
                            <span class="label">Total Beings:</span>
                            <span class="value">${summary.total_beings}</span>
                        </div>
                        <div class="stat">
                            <span class="label">Accessible:</span>
                            <span class="value">${summary.accessible_beings}</span>
                        </div>
                    </div>
                    <div class="zones-breakdown">
                `;

                Object.entries(summary.zones).forEach(([zoneId, zoneInfo]) => {
                    const accessIcon = zoneInfo.has_access ? '✅' : '❌';
                    const levelIcon = {
                        'public': '🌍',
                        'authenticated': '🔒',
                        'sensitive': '🔐'
                    }[zoneInfo.access_level] || '❓';

                    html += `
                        <div class="zone-summary ${zoneInfo.has_access ? 'accessible' : 'denied'}">
                            <div class="zone-header">
                                ${levelIcon} ${zoneId} ${accessIcon}
                            </div>
                            <div class="zone-details">
                                <div>${zoneInfo.description}</div>
                                <div class="zone-stats">
                                    ${zoneInfo.accessible_beings}/${zoneInfo.total_beings} beings accessible
                                </div>
                            </div>
                        </div>
                    `;
                });

                html += '</div>';
                content.innerHTML = html;
            }

            displayZones(zones) {
                const content = document.getElementById('zonesContent');
                let html = '';

                Object.entries(zones).forEach(([zoneId, zoneData]) => {
                    const levelIcon = {
                        'public': '🌍',
                        'authenticated': '🔒',
                        'sensitive': '🔐'
                    }[zoneData.access_level] || '❓';

                    html += `
                        <div class="zone-card ${zoneData.access_level}">
                            <div class="zone-title">
                                ${levelIcon} ${zoneId}
                                <button onclick="luxInterface.loadBeingsByZone('${zoneId}')" class="zone-btn">View Beings</button>
                            </div>
                            <div class="zone-description">${zoneData.description}</div>
                            <div class="zone-stats">
                                <div>Allowed Users: ${zoneData.allowed_users.length}</div>
                                <div>Access Rules: ${zoneData.access_rules.length}</div>
                            </div>
                        </div>
                    `;
                });

                content.innerHTML = html;
            }

            async loadBeingsByZone(zoneId) {
                const token = localStorage.getItem('luxToken');

                try {
                    const response = await fetch(`/api/beings/by_zone/${zoneId}`, {
                        headers: token ? { 'Authorization': `Bearer ${token}` } : {}
                    });
                    const data = await response.json();

                    if (data.beings) {
                        const beingsContainer = document.getElementById('chatMessages'); // Changed to chatMessages to display in chat flow
                        beingsContainer.innerHTML = ''; // Clear existing messages

                        const headerDiv = document.createElement('div');
                        headerDiv.className = 'message system';
                        headerDiv.innerHTML = `
                            <h4>🛡️ Beings in Zone: ${zoneId} (${data.total} found)</h4>
                            <button onclick="luxInterface.loadAccessData(); luxInterface.showMainInterface();" class="back-btn">← Back to Access Control</button>
                        `;
                        beingsContainer.appendChild(headerDiv);


                        data.beings.forEach(being => {
                            const beingDiv = this.createBeingElement(being);
                            beingsContainer.appendChild(beingDiv);
                        });

                        this.showMainInterface();
                    }
                } catch (error) {
                    console.error('Error loading beings by zone:', error);
                    alert('Error loading beings from zone');
                }
            }

            createBeingElement(being) {
                const beingDiv = document.createElement('div');
                beingDiv.className = 'message lux'; // Using lux message style for beings
                beingDiv.innerHTML = `
                    <strong>${being.alias || being.ulid.substring(0, 8)}</strong><br>
                    <small>Type: ${being.type || 'N/A'}</small><br>
                    <small>Access: ${being.access_level}</small><br>
                    <pre>${JSON.stringify(being.data, null, 2)}</pre>
                `;
                return beingDiv;
            }

            showMainInterface() {
                document.getElementById('accessControlPanel').style.display = 'none';
                document.getElementById('mainInterface').style.display = 'flex'; // Changed to flex to match lux-container
            }

            showAccessControl() {
                document.getElementById('mainInterface').style.display = 'none';
                document.getElementById('accessControlPanel').style.display = 'block';
                this.loadAccessData();
            }
        }

        // Global helper functions for WebSocket
        // Note: These should ideally be methods of LuxInterface or passed into it.
        // For simplicity and direct replacement, they are kept global here.
        function addMessage(type, content, timestamp) {
            // This function is called from the WebSocket logic.
            // It needs access to the chatMessages element.
            // Ideally, this should be part of the LuxInterface class.
            const chatMessages = document.getElementById('chatMessages');
            if (!chatMessages) return;

            const messageDiv = document.createElement('div');
            messageDiv.className = `message ${type}`;
            messageDiv.textContent = content;

            // Basic timestamping (replace with actual time if needed)
            if (timestamp) {
                const timeSpan = document.createElement('span');
                timeSpan.style.fontSize = '0.7em';
                timeSpan.style.opacity = '0.7';
                timeSpan.style.marginLeft = '10px';
                timeSpan.textContent = `(${timestamp})`;
                messageDiv.appendChild(timeSpan);
            }

            chatMessages.appendChild(messageDiv);
            chatMessages.scrollTop = chatMessages.scrollHeight;
        }

        function getUserInfo() {
            // Placeholder for user info - replace with actual logic to get user details
            // e.g., from auth tokens, cookies, etc.
            return { id: 'anonymous', username: 'Guest' };
        }

        function handleMessage(data) {
            // This function is called from the WebSocket logic.
            // It needs access to the LuxInterface instance to call its methods.
            if (window.luxInterface && typeof window.luxInterface.handleMessage === 'function') {
                window.luxInterface.handleMessage(data);
            } else {
                console.error("LuxInterface not initialized or handleMessage not found");
            }
        }

        // Initialize LuxInterface
        const luxInterface = new LuxInterface();

        // Placeholder for sessionContext if it exists, otherwise define dummy functions
        if (typeof sessionContext === 'undefined') {
            const sessionContext = {
                clear: () => console.log("sessionContext.clear() called"),
                // Add other methods if needed
            };
            window.sessionContext = sessionContext;
        }
    </script>
</body>
</html>