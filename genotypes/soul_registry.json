
{
  "genesis": {
    "name": "soul_registry", 
    "type": "registry_soul",
    "version": "1.0.0",
    "description": "Singleton zarządzający rejestrem dostępnych bytów z TTL"
  },
  "attributes": {
    "registered_beings": {"py_type": "dict", "default": {}},
    "ttl_cache": {"py_type": "dict", "default": {}},
    "registry_stats": {"py_type": "dict", "default": {}}
  },
  "module_source": "import asyncio\nfrom datetime import datetime, timedelta\n\ndef init(being_context=None):\n    \"\"\"Inicjalizuje rejestr jako singleton\"\"\"\n    print(f\"🏛️ Registry initialized: {being_context.get('alias')}\")\n    return {'registry_ready': True, 'singleton': True}\n\nasync def execute(action=None, being_ulid=None, ttl_hours=24, being_context=None):\n    \"\"\"Zarządza rejestrem bytów\"\"\"\n    from luxdb.models.being import Being\n    \n    registry_data = being_context.get('data', {})\n    registered = registry_data.get('registered_beings', {})\n    ttl_cache = registry_data.get('ttl_cache', {})\n    \n    if action == 'register':\n        # Zarejestruj byt z TTL\n        expiry = (datetime.now() + timedelta(hours=ttl_hours)).isoformat()\n        registered[being_ulid] = {'status': 'active', 'registered_at': datetime.now().isoformat()}\n        ttl_cache[being_ulid] = expiry\n        print(f\"📝 Registered being {being_ulid[:8]}... with TTL {ttl_hours}h\")\n        return {'registered': True, 'being_ulid': being_ulid, 'expires_at': expiry}\n        \n    elif action == 'get_or_wake':\n        # Sprawdź czy byt jest dostępny, jeśli nie - obudź go\n        if being_ulid in registered:\n            # Sprawdź TTL\n            if being_ulid in ttl_cache:\n                expiry = datetime.fromisoformat(ttl_cache[being_ulid])\n                if datetime.now() > expiry:\n                    # TTL wygasł - usuń z rejestru\n                    del registered[being_ulid]\n                    del ttl_cache[being_ulid]\n                    print(f\"⏰ Being {being_ulid[:8]}... TTL expired, removed from registry\")\n                else:\n                    print(f\"✅ Being {being_ulid[:8]}... found in registry\")\n                    return {'found': True, 'being_ulid': being_ulid}\n        \n        # Byt nie w rejestrze lub TTL wygasł - spróbuj go załadować\n        try:\n            being = await Being._get_by_ulid_internal(being_ulid)\n            if being:\n                # Auto-rejestracja\n                expiry = (datetime.now() + timedelta(hours=ttl_hours)).isoformat()\n                registered[being_ulid] = {'status': 'active', 'awakened_at': datetime.now().isoformat()}\n                ttl_cache[being_ulid] = expiry\n                print(f\"🌅 Being {being_ulid[:8]}... awakened and registered\")\n                return {'awakened': True, 'being_ulid': being_ulid, 'being': being}\n            else:\n                return {'error': 'being_not_found', 'being_ulid': being_ulid}\n        except Exception as e:\n            return {'error': str(e), 'being_ulid': being_ulid}\n            \n    elif action == 'cleanup':\n        # Wyczyść wygasłe TTL\n        now = datetime.now()\n        expired = []\n        for ulid, expiry_str in ttl_cache.copy().items():\n            if now > datetime.fromisoformat(expiry_str):\n                expired.append(ulid)\n                del registered[ulid]\n                del ttl_cache[ulid]\n        print(f\"🧹 Cleaned up {len(expired)} expired beings\")\n        return {'cleaned_up': len(expired), 'expired_beings': expired}\n        \n    return {'action': action, 'registry_size': len(registered)}"
}
