{
  "genesis": {
    "name": "soul_registry", 
    "type": "registry_soul",
    "version": "1.0.0",
    "description": "Singleton zarządzający rejestrem dostępnych bytów z TTL"
  },
  "attributes": {
    "registered_beings": {"py_type": "dict", "default": {}},
    "ttl_cache": {"py_type": "dict", "default": {}},
    "registry_stats": {"py_type": "dict", "default": {}}
  },
  "module_source": "import asyncio\nfrom datetime import datetime, timedelta\n\ndef init(being_context=None):\n    \"\"\"Registry byt zarządza dostępnymi bytami w systemie\"\"\"\n    print(f\"🏛️ Registry {being_context.get('alias', 'unknown')} initialized\")\n    return {\n        \"ready\": True,\n        \"role\": \"registry\",\n        \"managed_beings\": [],\n        \"suggested_persistence\": True\n    }\n\ndef execute(request=None, being_context=None, **kwargs):\n    \"\"\"Główna funkcja registry - zarządza rejestrem bytów\"\"\"\n    print(f\"🏛️ Registry processing request: {request}\")\n    \n    # Registry może zarządzać aktywacją, deaktywacją, TTL\n    # Na razie prosta implementacja\n    return {\n        \"registry_status\": \"active\",\n        \"managed_beings_count\": len(being_context.get('data', {}).get('managed_beings', [])),\n        \"timestamp\": \"2025-01-30T00:00:00\"\n    }\n\nasync def create_being_by_alias(soul_alias, attributes=None, persistent=True, being_context=None):\n    \"\"\"Tworzy Being na podstawie aliasu Soul - delegacja od Being.create()\"\"\"\n    print(f\"🏛️ Registry creating being from soul alias: {soul_alias}\")\n    \n    from luxdb.models.soul import Soul\n    from luxdb.models.being import Being\n    \n    # Znajdź Soul po aliasie\n    soul = await Soul.get_by_alias(soul_alias)\n    if not soul:\n        raise ValueError(f\"Soul with alias '{soul_alias}' not found\")\n    \n    # Utwórz Being bezpośrednio (bez alias!)\n    being = await Being._create_internal(\n        soul=soul, \n        attributes=attributes,\n        persistent=persistent\n    )\n    \n    # Zarejestruj w registry\n    await register_being(being.ulid, {\n        \"soul_alias\": soul_alias,\n        \"soul_hash\": soul.soul_hash,\n        \"created_by_registry\": True\n    }, being_context)\n    \n    return {\n        \"being\": being.to_json_serializable(),\n        \"registered\": True,\n        \"soul_alias\": soul_alias\n    }\n\ndef register_being(being_ulid, being_info=None, being_context=None):\n    \"\"\"Rejestruje nowy byt w registry\"\"\"\n    print(f\"📝 Registering being {being_ulid}\")\n    \n    managed_beings = being_context.get('data', {}).get('managed_beings', [])\n    managed_beings.append({\n        \"ulid\": being_ulid,\n        \"registered_at\": \"2025-01-30T00:00:00\",\n        \"info\": being_info or {}\n    })\n    \n    return {\n        \"registered\": True,\n        \"being_ulid\": being_ulid,\n        \"total_managed\": len(managed_beings)\n    }\n\ndef get_being_info(being_ulid, being_context=None):\n    \"\"\"Pobiera informacje o zarejestrowanym bycie\"\"\"\n    managed_beings = being_context.get('data', {}).get('managed_beings', [])\n    \n    for being_info in managed_beings:\n        if being_info.get('ulid') == being_ulid:\n            return being_info\n    \n    return None\n\ndef cleanup_expired(being_context=None):\n    \"\"\"Czyści wygasłe byty (TTL)\"\"\"\n    print(\"🧹 Cleaning up expired beings...\")\n    \n    # Implementacja TTL cleanup\n    return {\n        \"cleanup_completed\": True,\n        \"removed_count\": 0\n    }\n"
}