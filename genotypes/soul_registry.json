{
  "genesis": {
    "name": "soul_registry",
    "type": "registry_soul",
    "version": "1.0.0",
    "description": "Singleton zarzƒÖdzajƒÖcy rejestrem dostƒôpnych byt√≥w z TTL"
  },
  "attributes": {
    "registered_beings": {"py_type": "dict", "default": {}},
    "ttl_cache": {"py_type": "dict", "default": {}},
    "registry_stats": {"py_type": "dict", "default": {}}
  },
  "module_source": "import asyncio\nfrom datetime import datetime, timedelta\n\ndef init(being_context=None):\n    \"\"\"Registry byt zarzƒÖdza dostƒôpnymi bytami w systemie\"\"\"\n    print(f\"üèõÔ∏è Registry {being_context.get('alias', 'unknown')} initialized\")\n    return {\n        \"ready\": True,\n        \"role\": \"registry\",\n        \"managed_beings\": [],\n        \"suggested_persistence\": True\n    }\n\ndef execute(request=None, being_context=None, **kwargs):\n    \"\"\"G≈Ç√≥wna funkcja registry - zarzƒÖdza rejestrem byt√≥w i aliasami\"\"\"\n    print(f\"üèõÔ∏è Registry processing request: {request}\")\n\n    action = request.get('action') if request else 'status'\n\n    if action == 'register_alias':\n        return register_alias_mapping(\n            request.get('alias'), \n            request.get('soul_hash'), \n            being_context\n        )\n    elif action == 'get_current_hash':\n        return get_current_hash_for_alias(\n            request.get('alias'), \n            being_context\n        )\n    elif action == 'update_alias':\n        return update_alias_mapping(\n            request.get('alias'),\n            request.get('new_soul_hash'),\n            being_context\n        )\n\n    # Registry mo≈ºe zarzƒÖdzaƒá aktywacjƒÖ, deaktywacjƒÖ, TTL\n    return {\n        \"registry_status\": \"active\",\n        \"managed_beings_count\": len(being_context.get('data', {}).get('managed_beings', [])),\n        \"alias_mappings_count\": len(being_context.get('data', {}).get('alias_mappings', {})),\n        \"timestamp\": \"2025-01-30T00:00:00\"\n    }\n\ndef register_alias_mapping(alias, soul_hash, being_context):\n    \"\"\"Rejestruje mapowanie alias -> soul_hash\"\"\"\n    if not being_context.get('data'):\n        being_context['data'] = {}\n\n    if 'alias_mappings' not in being_context['data']:\n        being_context['data']['alias_mappings'] = {}\n\n    # Historia zmian aliasu\n    if 'alias_history' not in being_context['data']:\n        being_context['data']['alias_history'] = {}\n\n    old_hash = being_context['data']['alias_mappings'].get(alias)\n    being_context['data']['alias_mappings'][alias] = soul_hash\n\n    # Zapisz historiƒô\n    if alias not in being_context['data']['alias_history']:\n        being_context['data']['alias_history'][alias] = []\n\n    being_context['data']['alias_history'][alias].append({\n        \"soul_hash\": soul_hash,\n        \"updated_at\": \"2025-01-30T00:00:00\",\n        \"previous_hash\": old_hash\n    })\n\n    return {\n        \"success\": True,\n        \"alias\": alias,\n        \"soul_hash\": soul_hash,\n        \"previous_hash\": old_hash,\n        \"is_update\": old_hash is not None\n    }\n\ndef get_current_hash_for_alias(alias, being_context):\n    \"\"\"Pobiera aktualny hash dla aliasu\"\"\"\n    alias_mappings = being_context.get('data', {}).get('alias_mappings', {})\n    soul_hash = alias_mappings.get(alias)\n\n    if soul_hash:\n        return {\n            \"success\": True,\n            \"alias\": alias,\n            \"soul_hash\": soul_hash,\n            \"found\": True\n        }\n    else:\n        return {\n            \"success\": False,\n            \"alias\": alias,\n            \"found\": False,\n            \"error\": f\"No soul hash found for alias '{alias}'\"\n        }\n\ndef update_alias_mapping(alias, new_soul_hash, being_context):\n    \"\"\"Aktualizuje mapowanie aliasu na nowy soul_hash\"\"\"\n    return register_alias_mapping(alias, new_soul_hash, being_context)\n\n\ndef create_being_by_alias(soul_alias, attributes=None, persistent=True, being_context=None):\n    \"\"\"Tworzy Being na podstawie aliasu Soul - delegacja od Being.create()\"\"\"\n    print(f\"üèõÔ∏è Registry creating being from soul alias: {soul_alias}\")\n    \n    from luxdb.models.soul import Soul\n    from luxdb.models.being import Being\n    \n    # Znajd≈∫ Soul po aliasie\n    soul = await Soul.get_by_alias(soul_alias)\n    if not soul:\n        raise ValueError(f\"Soul with alias '{soul_alias}' not found\")\n    \n    # Utw√≥rz Being bezpo≈õrednio (bez alias!)\n    being = await Being._create_internal(\n        soul=soul, \n        attributes=attributes,\n        persistent=persistent\n    )\n    \n    # Zarejestruj w registry\n    await register_being(being.ulid, {\n        \"soul_alias\": soul_alias,\n        \"soul_hash\": soul.soul_hash,\n        \"created_by_registry\": True\n    }, being_context)\n    \n    return {\n        \"being\": being.to_json_serializable(),\n        \"registered\": True,\n        \"soul_alias\": soul_alias\n    }\n\ndef register_being(being_ulid, being_info=None, being_context=None):\n    \"\"\"Rejestruje nowy byt w registry\"\"\"\n    print(f\"üìù Registering being {being_ulid}\")\n    \n    managed_beings = being_context.get('data', {}).get('managed_beings', [])\n    managed_beings.append({\n        \"ulid\": being_ulid,\n        \"registered_at\": \"2025-01-30T00:00:00\",\n        \"info\": being_info or {}\n    })\n    \n    return {\n        \"registered\": True,\n        \"being_ulid\": being_ulid,\n        \"total_managed\": len(managed_beings)\n    }\n\ndef get_being_info(being_ulid, being_context=None):\n    \"\"\"Pobiera informacje o zarejestrowanym bycie\"\"\"\n    managed_beings = being_context.get('data', {}).get('managed_beings', [])\n    \n    for being_info in managed_beings:\n        if being_info.get('ulid') == being_ulid:\n            return being_info\n    \n    return None\n\ndef cleanup_expired(being_context=None):\n    \"\"\"Czy≈õci wygas≈Çe byty (TTL)\"\"\"\n    print(\"üßπ Cleaning up expired beings...\")\n    \n    # Implementacja TTL cleanup\n    return {\n        \"cleanup_completed\": True,\n        \"removed_count\": 0\n    }\n"
}